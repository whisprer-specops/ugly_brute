import time
from itertools import product

# List of top 50 most common passwords
common_passwords = [
    "123456", "password", "12345678", "qwerty", "123456789", "12345", "1234", "111111",
    "1234567", "dragon", "123123", "baseball", "abc123", "football", "monkey", "letmein",
    "696969", "shadow", "master", "666666", "qwertyuiop", "123321", "mustang", "1234567890",
    "michael", "654321", "superman", "1qaz2wsx", "7777777", "121212", "000000", "qazwsx",
    "123qwe", "killer", "trustno1", "jordan", "jennifer", "zxcvbnm", "asdfgh", "hunter",
    "buster", "soccer", "harley", "batman", "andrew", "tigger", "sunshine", "iloveyou", "2000"
]

# Function to generate lucky numbers
def sieve_lucky_numbers(n):
    numbers = list(range(1, n + 1, 2))  # Start with odd numbers only
    i = 1
    while i < len(numbers):
        step = numbers[i]
        numbers = [num for idx, num in enumerate(numbers) if (idx + 1) % step != 0]
        i += 1
    return numbers

# Generate the first 1000 lucky numbers as strings
lucky_numbers = sieve_lucky_numbers(1000)
lucky_numbers = [str(num) for num in lucky_numbers]

# Generate all possible password combinations
def gen_pswd_combos(knwn):
    digits = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()-_=+[]{}|;:,.<>?/~`'
    lngt = len(knwn)
    while True:
        for combos in product(digits, repeat=lngt):
            yield knwn + ''.join(combos)
        lngt += 1  # Increase the length after exhausting all combos of the current length

# Check if the generated password matches the real password
def is_rl_pswd(pswd, rl_pswd):
    return pswd == rl_pswd

def main():
    net_auto_password = 'password'  # The password we want to solve
    print(f"Actual real password to work from: {net_auto_password}")
    
    start_time = time.time()  # Start timing

    # First, try the lucky numbers
    for i, lucky_pswd in enumerate(lucky_numbers):
        print(f"Trying lucky number password {i}: {lucky_pswd}")
        if is_rl_pswd(lucky_pswd, net_auto_password):
            elapsed_time = time.time() - start_time  # Calculate elapsed time
            print(f"Correct password found: {lucky_pswd}. Pretending to accept the login.")
            print(f"Elapsed time: {elapsed_time:.2f} seconds")
            return

    # Then, try the common passwords from the wordlist
    for i, common_pswd in enumerate(common_passwords):
        print(f"Trying common password {i}: {common_pswd}")
        if is_rl_pswd(common_pswd, net_auto_password):
            elapsed_time = time.time() - start_time  # Calculate elapsed time
            print(f"Correct password found: {common_pswd}. Pretending to accept the login.")
            print(f"Elapsed time: {elapsed_time:.2f} seconds")
            return
        
    # If not found in lucky numbers or common passwords, try the generated combinations
    combos = gen_pswd_combos('')
    for i, combo in enumerate(combos):
        print(f"Combo {i}: {combo}\n")
        print(f"Trying password: {combo}")
        if is_rl_pswd(combo, net_auto_password):
            elapsed_time = time.time() - start_time  # Calculate elapsed time
            print(f"Correct password found: {net_auto_password}. Pretending to accept the login.")
            print(f"Elapsed time: {elapsed_time:.2f} seconds")
            break

if __name__ == "__main__":
    main()
